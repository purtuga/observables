{"version":3,"sources":["webpack://__LIB/webpack/bootstrap","webpack://__LIB/external \"(window.Set.Set = window.Set)\"","webpack://__LIB/./node_modules/@purtuga/common/src/jsutils/runtime-aliases.js","webpack://__LIB/./node_modules/@purtuga/common/src/jsutils/nextTick.js","webpack://__LIB/./src/objectWatchProp.js","webpack://__LIB/./src/objectCreateComputedProp.js","webpack://__LIB/./src/arrayWatch.js","webpack://__LIB/./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","window","Set","functionBindCall","Function","functionBind","toString","isObject","obj","objectDefineProperty","objectKeys","defineProperties","keys","prop","setter","configurable","writable","descriptor","set","getPropertyDescriptor","arr","isArray","Array","consoleLog","forEach","indexOf","splice","slice","console","log","error","warn","iterator","HTMLElementPrototype","HTMLElement","doc","document","head","appendChild","insertBefore","hasAttribute","getAttribute","setAttribute","removeAttribute","reIsNativeCode","nextTick","setImediate","test","Promise","resolved","resolve","fn","then","catch","e","immediates","processing","push","processPending","setTimeout","shift","length","isQueued","queuedCallbacks","flushQueue","callbacks","clear","queue","callback","add","OBSERVABLE_IDENTIFIER","DEFAULT_PROP_DEFINITION","TRACKERS","WATCHER_IDENTIFIER","ARRAY_WATCHABLE_PROTO","HAS_ARRAY_WATCHABLE_PROTO","ARRAY_MUTATING_METHODS","queueForNextTick","isObservable","isPropObservable","props","isBoolean","b","objectWatchProp","setupObjState","setupPropAsObservable","setupInterceptors","setupPropInterceptors","storeCallback","makeObservable","unWatch","propSetup","dependents","delete","unsetCallbackAsWatcherOf","watchers","destroy","deep","setupCallbackStore","store","async","notify","propOldDescriptor","getOwnPropertyDescriptor","val","undefined","size","newVal","priorVal","parent","setupPropState","walk","force","makeArrayWatchable","walkArray","walkObject","this","pushCallbacksToQueue","execCallback","cb","asDependent","setCallbackAsWatcherOf","setDependencyTracker","unsetDependencyTracker","stopTrackerNotification","stopWatchingAll","watchersSet","watching","watcherList","arrCurrentProto","__proto__","arrProtoInterceptor","method","args","response","alwaysForceExec","objectCreateComputedProp","propValue","newValue","needsInitialization","allowSet","needsNewValue","isGeneratingNewValue","dependencyTracker","forceExec","setPropValue","silentSet","forProp","arrayWatch","__webpack_exports__"],"mappings":"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","file":"observables.esm.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = (window.Set.Set = window.Set);","/**\r\n * return a value to a given method\r\n *\r\n * @function\r\n * @param {Function} fn\r\n * @param {*} ctx The context to be assigned to `fn`\r\n * @return {Function}\r\n *\r\n * @example\r\n *\r\n * f = functionBin(function() { console.log(`Hello ${this.name}`); }, { name: \"Jackson\" });\r\n * f(); // => \"Hello Jackson\"\r\n */\r\nexport const functionBind = Function.bind.call.bind(Function.bind);\r\n\r\n/**\r\n * return a bound `.call` to the given method.\r\n *\r\n * @type function\r\n * @param {Function} fn\r\n * @return {Function}\r\n * @example\r\n *\r\n * forEach = functionBindCall(Array.prototype.forEach);\r\n * // same as doing: Array.prototype.forEach.call (but returns a new \"call\" method);\r\n */\r\nexport const functionBindCall = functionBind(Function.call.bind, Function.call);\r\n\r\n// Object ===============================================================================\r\nexport const toString                 = functionBindCall(Object.prototype.toString);\r\nexport const isObject                 = obj => toString(obj) === \"[object Object]\";\r\nexport const isString                 = obj => toString(obj) === \"[object String]\";\r\nexport const isFunction               = obj => toString(obj) === \"[object Function]\";\r\nexport const isNull                   = obj => toString(obj) === \"[object Null]\";\r\nexport const isUndefined              = obj => toString(obj) === \"[object Undefined]\";\r\nexport const objectDefineProperty     = Object.defineProperty;\r\nexport const objectDefineProperties   = Object.defineProperties;\r\nexport const objectKeys               = Object.keys;\r\nexport const getPropertyDescriptor    = (value, getter, setter, configurable = true, enumerable = false, writable = true) => {\r\n    const descriptor = {\r\n        configurable,\r\n        enumerable\r\n    };\r\n\r\n    if (getter || setter) {\r\n        descriptor.get = getter;\r\n        descriptor.set = setter;\r\n    } else {\r\n        descriptor.writable = writable;\r\n        descriptor.value = value;\r\n    }\r\n    return descriptor;\r\n};\r\nexport const defineProperty = (obj, prop, value, getter, setter, configurable = true, enumerable = false, writable = true) => {\r\n    objectDefineProperty(obj, prop, getPropertyDescriptor(value, getter, setter, configurable, enumerable, writable));\r\n    return obj;\r\n};\r\n\r\n\r\n// Array ===============================================================================\r\nconst arr = [];\r\nexport const isArray        = Array.isArray;\r\nexport const arrayForEach   = functionBindCall(arr.forEach);\r\nexport const arrayIndexOf   = functionBindCall(arr.indexOf);\r\nexport const arraySplice    = functionBindCall(arr.splice);\r\nexport const arraySlice    = functionBindCall(arr.slice);\r\n\r\n\r\n// Logging ===============================================================================\r\nexport const consoleLog = console.log; // eslint-disable-line\r\nexport const consoleError = console.error || consoleLog; // eslint-disable-line\r\nexport const consoleWarn = console.warn || consoleLog; // eslint-disable-line\r\n\r\n\r\n// Iterators ===============================================================================\r\nexport const SymbolIterator = \"undefined\" !== typeof Symbol && Symbol.iterator ? Symbol.iterator : \"@@iterator\";\r\n\r\n\r\n// DOM ===============================================================================\r\n// *** In a NodeJS env - set HTMLElement to an empty object ***\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    if (typeof HTMLElement === \"undefined\") {\r\n        global.HTMLElement = class {}; // eslint-disable-line\r\n        global.document = class {};\r\n    }\r\n}\r\nconst HTMLElementPrototype = HTMLElement.prototype;\r\nexport const doc = document;\r\nexport const head = doc.head;\r\nexport const createDocFragment = () => doc.createDocumentFragment();\r\nexport const createElement = tagName => doc.createElement(tagName);\r\nexport const createTextNode = data => doc.createTextNode(data || \"\");\r\nexport const appendChild = functionBindCall(HTMLElementPrototype.appendChild);\r\nexport const insertBefore = functionBindCall(HTMLElementPrototype.insertBefore);\r\nexport const hasAttribute = functionBindCall(HTMLElementPrototype.hasAttribute);\r\nexport const getAttribute = functionBindCall(HTMLElementPrototype.getAttribute);\r\nexport const setAttribute = functionBindCall(HTMLElementPrototype.setAttribute);\r\nexport const removeAttribute = functionBindCall(HTMLElementPrototype.removeAttribute);\r\nexport const isDocFragment = node => toString(node) === \"[object DocumentFragment]\";\r\n","/* global setImediate:true */\r\nlet reIsNativeCode = /native code/i;\r\n\r\n/**\r\n * Executes a function at the end of the current event Loop - during micro-task processing\r\n *\r\n * @param {Function} callback\r\n */\r\nlet nextTick = (function(){\r\n    if (typeof setImediate !== \"undefined\" && reIsNativeCode.test(setImediate.toString())) {\r\n        return setImediate;\r\n    }\r\n\r\n    // Native Promsie? Use it.\r\n    if (typeof Promise === 'function' && reIsNativeCode.test(Promise.toString())) {\r\n        let resolved = Promise.resolve();\r\n        return function _nextTickPromise(fn) {\r\n            resolved.then(fn).catch(e => console.error(e)); // eslint-disable-line\r\n        };\r\n    }\r\n\r\n    // fallback to setTimeout\r\n    // From: https://bugzilla.mozilla.org/show_bug.cgi?id=686201#c68\r\n    let immediates = [];\r\n    let processing = false;\r\n\r\n    function processPending() {\r\n        setTimeout(function() {\r\n            immediates.shift()();\r\n            if (immediates.length) {\r\n                processPending();\r\n            } else {\r\n                processing = false;\r\n            }\r\n        }, 0);\r\n    }\r\n\r\n    return function _nextTickSetTimeout(fn) {\r\n        immediates.push(fn);\r\n        if (!processing) {\r\n            processing = true;\r\n            processPending();\r\n        }\r\n    };\r\n})();\r\n\r\nlet isQueued = false;\r\nconst queuedCallbacks = new Set();\r\nlet i, t;\r\nconst flushQueue = () => {\r\n    const callbacks = [ ...queuedCallbacks ];\r\n    queuedCallbacks.clear();\r\n    isQueued = false;\r\n    for (i = 0, t = callbacks.length; i < t; i++) {\r\n        callbacks[i]();\r\n    }\r\n};\r\n\r\n/**\r\n * Queues a callback to be executed on nextTick. Unlike calling `nextTick` directly\r\n * `queue()` will ensure that the same callback is not executed more than once when\r\n * `nextTick` runs.\r\n *\r\n * @param {Function} callback\r\n */\r\nfunction queueForNextTick(callback) {\r\n    queuedCallbacks.add(callback);\r\n    if (!isQueued) {\r\n        isQueued = true;\r\n        nextTick(flushQueue);\r\n    }\r\n}\r\n\r\n/**\r\n * Queue a callback for next tick\r\n * @type {queueForNextTick}\r\n */\r\nnextTick.queue = queueForNextTick;\r\n\r\n//-----------------------------------------------------------[ EXPORTS ]---\r\nexport default nextTick;\r\nexport {\r\n    nextTick,\r\n    queueForNextTick\r\n}\r\n","import {\r\n    objectKeys,\r\n    isArray,\r\n    isObject,\r\n    defineProperty\r\n} from \"@purtuga/common/src/jsutils/runtime-aliases.js\";\r\nimport Set from \"@purtuga/common/src/jsutils/Set.js\"\r\nimport nextTick from \"@purtuga/common/src/jsutils/nextTick.js\"\r\n\r\n//---------------------------------------------------------------------------\r\nexport const OBSERVABLE_IDENTIFIER = \"___$observable$___\";\r\n\r\nconst DEFAULT_PROP_DEFINITION = { configurable: true, enumerable: true };\r\nlet TRACKERS = new Set();\r\nconst WATCHER_IDENTIFIER = \"___$watching$___\";\r\nconst ARRAY_WATCHABLE_PROTO = \"__$watchable$__\";\r\nconst HAS_ARRAY_WATCHABLE_PROTO = `__$is${ARRAY_WATCHABLE_PROTO}`;\r\nconst ARRAY_MUTATING_METHODS = [\r\n    \"pop\",\r\n    \"push\",\r\n    \"shift\",\r\n    \"splice\",\r\n    \"unshift\",\r\n    \"sort\",\r\n    \"reverse\"\r\n];\r\n\r\nconst queueForNextTick = nextTick.queue;\r\nexport const isObservable = obj => !!obj[OBSERVABLE_IDENTIFIER];\r\nexport const isPropObservable = (obj, prop) => obj && prop && isObservable(obj) && !!obj[OBSERVABLE_IDENTIFIER].props[prop];\r\nconst isBoolean = b => (\"boolean\" === typeof b);\r\n\r\n// DEV MODE\r\n// This facilitates when in dev mode and using npm link'ed package.\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    if (typeof window !== \"undefined\") {\r\n        if (!window._OBSERVABLE_TRACKERS ) {\r\n            window._OBSERVABLE_TRACKERS = TRACKERS;\r\n        } else {\r\n            TRACKERS = window._OBSERVABLE_TRACKERS;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A lightweight utility to Watch an object's properties and get notified when it changes.\r\n *\r\n * @param {Object} obj\r\n *\r\n * @param {String} [prop]\r\n *  the property to be watched. If left undefined, then all existing properties are watched.\r\n *\r\n * @param {Function} [callback]\r\n *  The callback to be executed when property or object changes. If left undefined, then\r\n *  `obj` is only made observable (internal structure created and all current enumerable'\r\n *  properties are made \"watchable\")\r\n *\r\n *  __NOTE:__\r\n *  The callback will include a new non-enumerable property named `stopWatchingAll` of\r\n *  type `Function` that can be used to remove the given callback from all places where\r\n *  it is being used to watch a property. example:\r\n *\r\n *      const obj1 = { first: \"john\" };\r\n *      const obj2 = { last: \"smith\" };\r\n *      const watcher = () => console.log(\"changed\");\r\n *\r\n *      objectWatchProp(obj, \"first\", watcher);\r\n *      objectWatchProp(obj1, \"last\", watcher);\r\n *\r\n *      watcher.stopWatchingAll(); // removes callback from all objects that it is watching\r\n *\r\n *\r\n * @return {ObjectUnwatchProp}\r\n * Return a function to unwatch the property. Function also has a static property named\r\n * `destroy` that will do the same thing (ex. `unwatch.destroy()` is same as `unwatch()`)\r\n *\r\n * @example\r\n *\r\n * const oo = {};\r\n * const notifyNameChanged =() => console.log(`name changed: ${oo.name}`);\r\n * const unWatchName = objectWatchProp(oo, \"name\", notifyNameChanged);\r\n *\r\n * oo.name = \"paul\"; // console outputs: name changed: paul\r\n * unWatchName(); // stop watching\r\n * notifyNameChanged.stopWatchingAll(); // callback's `stopWatchingAll()` can also be called.\r\n *\r\n * @example\r\n *\r\n * const oo = {\r\n *      name: \"paul\",\r\n *      country: \"usa\"\r\n * };\r\n *\r\n * // watch all changes to object\r\n * objectWatchProp(oo, null, () => console.log(\"Something changed in object\"));\r\n *\r\n * // OR: make all properties of object observable\r\n * objectWatchProp(oo);\r\n *\r\n */\r\nexport function objectWatchProp(obj, prop, callback) {\r\n    if (!isObservable(obj)) {\r\n        setupObjState(obj);\r\n    }\r\n\r\n    // Convert prop to observable?\r\n    if (prop && !isPropObservable(obj, prop)) {\r\n        setupPropAsObservable(obj, prop);\r\n    }\r\n    // Else: do we need to setup the interceptors (again)?\r\n    // (Used by Computed props when they are created against a prop has\r\n    // been setup as an observable)\r\n    else if (prop && obj[OBSERVABLE_IDENTIFIER].props[prop].setupInterceptors) {\r\n        setupPropInterceptors(obj, prop);\r\n    }\r\n\r\n    if (prop && callback) {\r\n        obj[OBSERVABLE_IDENTIFIER].props[prop].storeCallback(callback);\r\n    }\r\n    else if (!prop) {\r\n        makeObservable(obj, false);\r\n\r\n        if (callback) {\r\n            obj[OBSERVABLE_IDENTIFIER].storeCallback(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unwatch an object property or object.\r\n     *\r\n     * @typedef {Function} ObjectUnwatchProp\r\n     * @property {Function} destroy Same as function returned.\r\n     */\r\n    const unWatch = destroyWatcher.bind(\r\n        obj,\r\n        callback,\r\n        (prop ? obj[OBSERVABLE_IDENTIFIER].props[prop] : obj[OBSERVABLE_IDENTIFIER])\r\n    );\r\n\r\n    unWatch.destroy = unWatch;\r\n    return unWatch;\r\n}\r\n\r\nexport function setupObjState(obj) {\r\n    if (!isObservable(obj)) {\r\n        defineProperty(\r\n            obj,\r\n            OBSERVABLE_IDENTIFIER,\r\n            {\r\n                deep: false,\r\n                props: {},\r\n                dependents: new Set(),\r\n                watchers: new Set(),\r\n                storeCallback: storeCallback\r\n            }\r\n        );\r\n\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].dependents, false);\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].watchers, true);\r\n    }\r\n}\r\n\r\nfunction setupCallbackStore (store, async = false) {\r\n    store.async = async;\r\n    store.isQueued = false;\r\n    store.notify = notify;\r\n}\r\n\r\nfunction setupPropState(obj, prop) {\r\n    if (!isPropObservable(obj, prop)) {\r\n        obj[OBSERVABLE_IDENTIFIER].props[prop] = {\r\n            val: undefined,\r\n            dependents: new Set(),\r\n            watchers: new Set(),\r\n            parent: obj[OBSERVABLE_IDENTIFIER],\r\n            storeCallback: storeCallback,\r\n            setupInterceptors: true,\r\n            deep: obj[OBSERVABLE_IDENTIFIER].deep\r\n        };\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].props[prop].dependents, false);\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].props[prop].watchers, true);\r\n    }\r\n    return obj[OBSERVABLE_IDENTIFIER].props[prop];\r\n}\r\n\r\nfunction setupPropInterceptors(obj, prop, configurable, enumerable) {\r\n    const propOldDescriptor =\r\n        Object.getOwnPropertyDescriptor(obj, prop) || DEFAULT_PROP_DEFINITION;\r\n\r\n    if (!propOldDescriptor.get) {\r\n        obj[OBSERVABLE_IDENTIFIER].props[prop].val = obj[prop];\r\n\r\n        // If prop is marked as `deep` then walk the value and convert it to observables\r\n        if (obj[OBSERVABLE_IDENTIFIER].props[prop].deep) {\r\n            makeObservable(obj[OBSERVABLE_IDENTIFIER].props[prop].val);\r\n        }\r\n    }\r\n\r\n    defineProperty(\r\n        obj,\r\n        prop,\r\n        undefined,\r\n        function() {\r\n            if (TRACKERS.size) {\r\n                TRACKERS.forEach(\r\n                    obj[OBSERVABLE_IDENTIFIER].props[prop].storeCallback,\r\n                    obj[OBSERVABLE_IDENTIFIER].props[prop]\r\n                );\r\n            }\r\n\r\n            if (propOldDescriptor.get) {\r\n                return propOldDescriptor.get.call(obj);\r\n            }\r\n\r\n            return obj[OBSERVABLE_IDENTIFIER].props[prop].val;\r\n        },\r\n        function(newVal) {\r\n            const priorVal = obj[prop];\r\n            if (propOldDescriptor.set) {\r\n                newVal = propOldDescriptor.set.call(obj, newVal);\r\n            } else {\r\n                obj[OBSERVABLE_IDENTIFIER].props[prop].val = newVal;\r\n            }\r\n\r\n            // If this `deep` is true and the new value is an object,\r\n            // then ensure its observable\r\n            if (obj[OBSERVABLE_IDENTIFIER].props[prop].deep) {\r\n                makeObservable(newVal);\r\n            }\r\n\r\n            if (newVal !== priorVal) {\r\n                obj[OBSERVABLE_IDENTIFIER].props[prop].watchers.notify();\r\n                obj[OBSERVABLE_IDENTIFIER].props[prop].dependents.notify();\r\n                obj[OBSERVABLE_IDENTIFIER].watchers.notify();\r\n            }\r\n\r\n            return newVal;\r\n        },\r\n        isBoolean(configurable) ? configurable :  propOldDescriptor.configurable || false,\r\n        isBoolean(enumerable) ? enumerable : propOldDescriptor.enumerable || false\r\n    );\r\n\r\n    obj[OBSERVABLE_IDENTIFIER].props[prop].setupInterceptors = false;\r\n\r\n    // Notify object watchers that a new prop was added\r\n    if (propOldDescriptor === DEFAULT_PROP_DEFINITION) {\r\n        obj[OBSERVABLE_IDENTIFIER].watchers.notify();\r\n    }\r\n}\r\n\r\nexport function setupPropAsObservable(obj, prop, configurable, enumerable) {\r\n    setupPropState(obj, prop);\r\n    setupPropInterceptors(obj, prop, configurable, enumerable);\r\n}\r\n\r\n/**\r\n * Makes an object (deep) observable.\r\n *\r\n * @param {Object|Array} obj\r\n * @param {Boolean} [walk=true]\r\n *  If `true` (default), the object's property values are walked and\r\n *  also made observable.\r\n * @param {Boolean} [force=false]\r\n *  if true, then even if object looks like it might have already been\r\n *  converted to an observable, it will still be walked\r\n *  (if `walk` is `true`)\r\n *\r\n * @return {Object|Array} Original `obj` is returned\r\n */\r\nexport function makeObservable(obj, walk = true, force = false) {\r\n    if (!isObject(obj) && !isArray(obj)) {\r\n        return obj;\r\n    }\r\n\r\n    if (!isObservable(obj)) {\r\n        // OBJECT\r\n        if (isObject(obj)) {\r\n            setupObjState(obj, force);\r\n        }\r\n        // ARRAY\r\n        else if (isArray(obj)) {\r\n            makeArrayWatchable(obj, force);\r\n        }\r\n    }\r\n\r\n    // If object is marked as \"deep\" and we are not forcing the walk,\r\n    // then no need to do anything. Otherwise, mark this object as\r\n    // being `deep` and keep going\r\n    if (!force && obj[OBSERVABLE_IDENTIFIER].deep) {\r\n        return;\r\n    }\r\n    else if (walk) {\r\n        obj[OBSERVABLE_IDENTIFIER].deep = true;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        walkArray(obj);\r\n    }\r\n    else {\r\n        walkObject(obj);\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nfunction walkArray(arr, force) {\r\n    for (let i=0, t=arr.length; i<t; i++) {\r\n        makeObservable(arr[i], true, force);\r\n    }\r\n}\r\n\r\nfunction walkObject(obj, force) {\r\n    // make ALL props observable\r\n    const keys = objectKeys(obj);\r\n\r\n    for (let i=0, t=keys.length; i<t; i++) {\r\n        if (!obj[OBSERVABLE_IDENTIFIER].props[keys[i]]) {\r\n            setupPropAsObservable(obj, keys[i]);\r\n        }\r\n\r\n        // Do we need to walk this property's value?\r\n        if (\r\n            !obj[OBSERVABLE_IDENTIFIER].props[keys[i]].deep ||\r\n            force\r\n        ) {\r\n            obj[OBSERVABLE_IDENTIFIER].props[keys[i]].deep = true;\r\n\r\n            if (isObject(obj[keys[i]])) {\r\n                makeObservable(obj[keys[i]], true, force);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction notify() {\r\n    // this: new Set(). Set instance could have two additional attributes: async ++ isQueued\r\n\r\n    if (!this.size) {\r\n        return;\r\n    }\r\n\r\n    // If the watcher Set() is synchronous, then execute the callbacks now\r\n    if (!this.async) {\r\n        this.forEach(execCallback);\r\n\r\n    } else {\r\n        this.forEach(pushCallbacksToQueue);\r\n    }\r\n}\r\n\r\nfunction pushCallbacksToQueue(callback) {\r\n    queueForNextTick(callback);\r\n}\r\n\r\nfunction execCallback(cb) {\r\n    cb();\r\n}\r\n\r\nfunction storeCallback(callback) {\r\n    // this === PropState\r\n    if (callback.asDependent && this.dependents) {\r\n        setCallbackAsWatcherOf(callback, this.dependents);\r\n        this.dependents.add(callback);\r\n    } else {\r\n        setCallbackAsWatcherOf(callback, this.watchers);\r\n        this.watchers.add(callback);\r\n    }\r\n}\r\n\r\nexport function destroyWatcher(callback, propSetup) {\r\n    // this == obj\r\n    if (callback) {\r\n        // Object state does not have dependents\r\n        if (propSetup.dependents) {\r\n            propSetup.dependents.delete(callback);\r\n            unsetCallbackAsWatcherOf(callback, propSetup.dependents);\r\n        }\r\n        propSetup.watchers.delete(callback);\r\n        unsetCallbackAsWatcherOf(callback, propSetup.watchers);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets a callback to be added to the list of watchers for any property\r\n * that is accessed after this function is called.\r\n *\r\n * @param {Function} callback\r\n *  The callback to be added to dependency list of watchers.\r\n *  NOTE: the callback will modified to include a new property\r\n *  `stopWatchingAll()` which can be used to remove the given callback\r\n *  from ALL dependencies that include it.\r\n *\r\n */\r\nexport function setDependencyTracker(callback) {\r\n    TRACKERS.add(callback);\r\n}\r\n\r\n/**\r\n * Removes a callback from being added to a property's watchers as they\r\n * are accessed.\r\n *\r\n * @param {Function} callback\r\n */\r\nexport function unsetDependencyTracker(callback) {\r\n    TRACKERS.delete(callback);\r\n}\r\n\r\n/**\r\n * Removes the given callback from all property watchers lists that it may\r\n * be included in.\r\n *\r\n * @param {Function} callback\r\n */\r\nexport function stopTrackerNotification(callback) {\r\n    if (callback && callback.stopWatchingAll) {\r\n        callback.stopWatchingAll();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Store a reference to the Set instance provided on input, on the callback.\r\n * @private\r\n * @param {Function} callback\r\n * @param {Set} watchersSet\r\n */\r\nfunction setCallbackAsWatcherOf(callback, watchersSet) {\r\n    if (!callback[WATCHER_IDENTIFIER]) {\r\n        defineProperty(callback, WATCHER_IDENTIFIER, { watching: new Set() });\r\n\r\n        defineProperty(callback, \"stopWatchingAll\", function(){\r\n            callback[WATCHER_IDENTIFIER].watching.forEach(watcherList =>\r\n                watcherList.delete(callback)\r\n            );\r\n            callback[WATCHER_IDENTIFIER].watching.clear();\r\n        });\r\n    }\r\n\r\n    callback[WATCHER_IDENTIFIER].watching.add(watchersSet);\r\n}\r\n\r\n/**\r\n * Removes the reference to the given Set instance from the callback function provided\r\n * @private\r\n * @param {Function} callback\r\n * @param {Set} watchersSet\r\n */\r\nfunction unsetCallbackAsWatcherOf(callback, watchersSet) {\r\n    if (callback[WATCHER_IDENTIFIER]) {\r\n        callback[WATCHER_IDENTIFIER].watching.delete(watchersSet);\r\n    }\r\n}\r\n\r\n\r\nexport function makeArrayWatchable(arr) {\r\n    if (!isObservable(arr)) {\r\n        setupObjState(arr);\r\n    }\r\n\r\n    // If array already has a watchable prototype, then exit\r\n    if (arr[HAS_ARRAY_WATCHABLE_PROTO]) {\r\n        return;\r\n    }\r\n\r\n    const arrCurrentProto = arr.__proto__; // eslint-disable-line\r\n\r\n    // Create prototype interceptors?\r\n    if (!arrCurrentProto[ARRAY_WATCHABLE_PROTO]) {\r\n        const arrProtoInterceptor = Object.create(arrCurrentProto);\r\n        ARRAY_MUTATING_METHODS.forEach(method => {\r\n            defineProperty(arrProtoInterceptor, method, function arrayMethodInterceptor(...args) {\r\n                // FIXME: need to call `makeObservable` on any value that was inserted, if `deep` is true\r\n                const response = arrCurrentProto[method].call(this, ...args);\r\n                this[OBSERVABLE_IDENTIFIER].dependents.notify();\r\n                this[OBSERVABLE_IDENTIFIER].watchers.notify();\r\n                return response;\r\n            });\r\n        });\r\n\r\n        // VALUE ADD: include a `size` read only attribute\r\n        defineProperty(arrProtoInterceptor, \"size\", undefined, function(){\r\n            if (TRACKERS.size) {\r\n                TRACKERS.forEach(\r\n                    this[OBSERVABLE_IDENTIFIER].storeCallback,\r\n                    this[OBSERVABLE_IDENTIFIER]\r\n                );\r\n            }\r\n            return this.length;\r\n        });\r\n\r\n        // Add flag to new array interceptor prototype indicating its watchable\r\n        defineProperty(arrProtoInterceptor, HAS_ARRAY_WATCHABLE_PROTO, true);\r\n\r\n        // Store the new interceptor prototype on the real prototype\r\n        defineProperty(arrCurrentProto, ARRAY_WATCHABLE_PROTO, arrProtoInterceptor);\r\n    }\r\n\r\n    arr.__proto__ = arrCurrentProto[ARRAY_WATCHABLE_PROTO]; // eslint-disable-line\r\n}\r\n\r\n\r\nexport default objectWatchProp;\r\n","import {defineProperty} from \"@purtuga/common/src/jsutils/runtime-aliases.js\"\r\nimport nextTick from \"@purtuga/common/src/jsutils/nextTick.js\"\r\nimport {\r\n    OBSERVABLE_IDENTIFIER,\r\n    objectWatchProp,\r\n    setDependencyTracker,\r\n    unsetDependencyTracker,\r\n    makeObservable\r\n} from \"./objectWatchProp.js\";\r\n\r\n//================================================================================\r\nlet alwaysForceExec = false;\r\n\r\n/**\r\n * Creates a computed property on a given object.\r\n *\r\n * @param {Object} obj\r\n *\r\n * @param {String} prop\r\n *\r\n * @param {Function} setter\r\n *  A callback function that will be used to retrieve the computed prop's\r\n *  value. Function is called with a context (`this`) of the object and\r\n *  will receive one input param - the Object itself.\r\n *  Callback is executed only when the property is accessed or a tracked\r\n *  dependency changes AND watchers or dependents on this computed exist.\r\n *  To force a value to be generated everytime (even if no dependents/watchers)\r\n *  add a property to the function named `forceExec=true`.\r\n *\r\n * @param {Boolean} [enumerable=true]\r\n *\r\n * @example\r\n * const obj = {\r\n *     firstName: \"paul\",\r\n *     lastName: \"Tavares\"\r\n * };\r\n *\r\n * objectCreateComputedProp(obj, \"name\", function () {\r\n *     return `${ this.firstName } ${ this.lastName }`;\r\n * });\r\n *\r\n * // Or, to always force the callback to generate a value\r\n * function generateName() {\r\n *     return `${ this.firstName } ${ this.lastName }`;\r\n * }\r\n * generateName.forceExec = true;\r\n * objectCreateComputedProp(obj, \"name\", genereateName);\r\n *\r\n *\r\n */\r\nfunction objectCreateComputedProp(obj, prop, setter, enumerable = true) {\r\n    let propValue;\r\n    let newValue;\r\n    let needsInitialization = true;\r\n    let allowSet = false;\r\n    let needsNewValue = true;\r\n    let isGeneratingNewValue = false;\r\n\r\n    const dependencyTracker = () => {\r\n        if (needsNewValue) {\r\n            return;\r\n        }\r\n\r\n        needsNewValue = true;\r\n\r\n        // If we have watchers on this computed prop, then queue the\r\n        // value generator function.\r\n        // else, just notify dependents.\r\n        if (alwaysForceExec || setter.forceExec || obj[OBSERVABLE_IDENTIFIER].props[prop].watchers.size) {\r\n            nextTick.queue(setPropValue);\r\n        }\r\n        else if (obj[OBSERVABLE_IDENTIFIER].props[prop].dependents.size) {\r\n            obj[OBSERVABLE_IDENTIFIER].props[prop].dependents.notify();\r\n        }\r\n    };\r\n\r\n    const setPropValue = silentSet => {\r\n        // if there is no longer a need to regenerate the value, exit.\r\n        // this can happen when other logic accesses the computed getter\r\n        // between scheduled updates.\r\n        // Also, in order to avoid looping, if value is currently being\r\n        // generated, then also exit.\r\n        if (!needsNewValue || isGeneratingNewValue) {\r\n            return;\r\n        }\r\n\r\n        isGeneratingNewValue = true;\r\n\r\n        try {\r\n            setDependencyTracker(dependencyTracker);\r\n            newValue = setter.call(obj, obj);\r\n            unsetDependencyTracker(dependencyTracker); // IMPORTANT: turn if off right after setter is run!\r\n\r\n            if (silentSet) {\r\n                propValue = newValue;\r\n\r\n                if (obj[OBSERVABLE_IDENTIFIER].props[prop].deep) {\r\n                    makeObservable(propValue);\r\n                }\r\n            } else {\r\n                // Update is done via the prop assignment, which means that\r\n                // handing of `deep` and all dependent/watcher notifiers is handled\r\n                // as part of the objectWatchProp() functionality.\r\n                // Doing the update this way also supports the use of these\r\n                // objects with other library that may also intercept getter/setters.\r\n                allowSet = true;\r\n                needsNewValue = false;\r\n                obj[prop] = newValue;\r\n            }\r\n        } catch (e) {\r\n            allowSet = needsNewValue = isGeneratingNewValue = false;\r\n            newValue = undefined;\r\n            unsetDependencyTracker(dependencyTracker);\r\n            throw e;\r\n        }\r\n\r\n        allowSet = needsNewValue = isGeneratingNewValue = false;\r\n        newValue = undefined;\r\n    };\r\n\r\n    dependencyTracker.asDependent = true;\r\n    dependencyTracker.forProp = setPropValue.forProp = prop;\r\n\r\n    // Does property already exists? Delete it.\r\n    if (prop in obj) {\r\n        delete obj[prop];\r\n\r\n        // Was prop an observable? if so, signal that interceptors must be redefined.\r\n        if (obj[OBSERVABLE_IDENTIFIER] && obj[OBSERVABLE_IDENTIFIER].props[prop]) {\r\n            obj[OBSERVABLE_IDENTIFIER].props[prop].setupInterceptors = true;\r\n        }\r\n    }\r\n\r\n    defineProperty(\r\n        obj,\r\n        prop,\r\n        undefined,\r\n        function(){\r\n            if (needsInitialization) {\r\n                needsInitialization = false;\r\n                setPropValue(true);\r\n            }\r\n            else if (needsNewValue) {\r\n                setPropValue();\r\n            }\r\n\r\n            return propValue;\r\n        },\r\n        function () {\r\n            if (allowSet) {\r\n                propValue = newValue;\r\n            }\r\n            return propValue;\r\n        },\r\n        true,\r\n        !!enumerable\r\n    );\r\n\r\n    objectWatchProp(obj, prop);\r\n}\r\n\r\n/**\r\n * Set/unset the `forceExec` which (when `true` causes all computed value generator\r\n * to always be called on dependency changes (even if internally to this library,\r\n * there are no watchers/dependents on it).\r\n *\r\n * @param {Boolean} force\r\n */\r\nfunction setForceExec(force) {\r\n    alwaysForceExec = force;\r\n}\r\n\r\n//=======================================================[ EXPORTS ]==========\r\nexport default objectCreateComputedProp;\r\nexport { objectCreateComputedProp, setForceExec }","import { OBSERVABLE_IDENTIFIER, makeArrayWatchable } from \"./objectWatchProp\";\r\n\r\n//========================================================================\r\n\r\n/**\r\n * Watch an array for changes.  Utiltiy will override the array's mutating methods\r\n * so that notification can be provided to watchers when it changes\r\n *\r\n * @param {Array} arr\r\n * @param {Function} [callback]\r\n *  If not defined, then array is simply made \"watchable\"\r\n */\r\nexport function arrayWatch(arr, callback) {\r\n    if (!arr[OBSERVABLE_IDENTIFIER]) {\r\n        makeArrayWatchable(arr);\r\n    }\r\n\r\n    if (callback) {\r\n        arr[OBSERVABLE_IDENTIFIER].storeCallback(callback);\r\n    }\r\n\r\n    const unWatch = () => arr[OBSERVABLE_IDENTIFIER].watchers.delete(callback);\r\n    unWatch.destroy = unWatch;\r\n    return unWatch;\r\n}\r\nexport default arrayWatch;\r\n","export {\r\n    objectWatchProp,\r\n    makeObservable,\r\n    setDependencyTracker,\r\n    stopTrackerNotification,\r\n    unsetDependencyTracker\r\n} from \"./objectWatchProp\"\r\nexport {objectCreateComputedProp} from \"./objectCreateComputedProp\"\r\nexport {arrayWatch} from \"./arrayWatch\""],"sourceRoot":""}